### 1.跨域是怎么处理的

* 让后端配合 配置一个CORS
* jsonp
* domain

### 2.盒模型

* 标准模型

  * width = content

* IE模型

  * width = border + padding + content

  

### 3.get/post的区别

| 区别                    | post                           | get                                                          |
| ----------------------- | ------------------------------ | ------------------------------------------------------------ |
| 在url地址栏中的显示问题 | post请求不会显示参数在地址栏中 | 显示在地址栏中                                               |
| 传输的数据量            | 最大2M                         | 最大1024字节                                                 |
| 缓存问题                | 不存在缓存问题                 | 有缓存                                                       |
| 安全问题                |                                | 请求的数据会被浏览器缓存起来，因此其他人可读取。参数名之类的比较暴露，都存在安全问题。 |
|                         | 通过一个body传过去             | 传递参数时是拼接在url后面                                    |



### 4.router和route的区别

  **$router对象是全局路由的实例，是router构造方法的实例。**

* $router对象是全局路由的实例，是router构造方法的实例；
* $route对象表示当前的路由信息，包含了当前 URL 解析得到的信息。包含当前的路径，参数，query对象等

### 5.虚拟dom是什么？





### 6.一个html页面是怎么渲染的

* 为什么要了解这个知识点，主要是为了性能的优化

  1. 了解浏览器如何进行加载，我们可以在引用外部样式文件，外部JS时，将它们放到合适的位置，是浏览器以最快的速度，将文件加载完毕。
  2. 了解浏览器如何进行解析，我们可以在构建DOM结构，组织CSS选择器的时候，选择最优的写法，提高浏览器的解析速率。
  3. 了解浏览器如何进行渲染，明白渲染的过程，我们在设置元素属性，编写JS文件时，可以减少“重绘”，“重新布局”的消耗。

* 基本概念

  1. DOM：Document Object Model

     浏览器将HTML解析成树形的数据结构，简称DOM。

  2. CSSOM：CSS Object Model

     浏览器将CSS解析成树形的数据结构，简称CSSOM。

  3. Render Tree: 

     DOM和CSSOM合并后生成Render Tree

  4. Layout: 

     计算出Render Tree每个节点的具体位置。

  5. Painting:

     通过显卡，将Layout后的节点内容分别呈现到屏幕上。

* 注意

  - 当我们浏览器获得HTML文件后，会自上而下的加载，并在加载过程中进行解析和渲染。

  - 加载说的就是获取资源文件的过程，如果在加载过程中遇**到外部CSS文件和图片**，浏览器会另外发送一个请求，去获取CSS文件和相应的图片，**这个请求是异步的**，并不会影响HTML文件的加载。

  - 但是如果**遇到Javascript文件**，HTML文件会**挂起**渲染的进程，**等待JavaScript文件加载完毕**后，再继续进行渲染。
    为什么HTML需要等待JavaScript呢？**因为JavaScript可能会修改DOM**，导致后续HTML资源白白加载，所以HTML必须等待JavaScript文件加载完毕后，再继续渲染，这也就是为**什么JavaScript文件在写在底部**body标签前的原因。

    

* 浏览器渲染的整个过程

  1. URL输入至浏览器
  2. 浏览器进行http请求
  3. 请求到之后，到html解析器
  4. html解析器
     1. DOM
     2. CSS解析器  ---  CSSOM
     3. Js解析器
  5. DOM树与CSSOM 以及js和css请求中的资源，共同生成render树
  6. 根据render树，生成layout树
  7. 渲染 paint

* 再看过程

  * 当用户输入一个URL时，浏览器就会向服务器发出一个请求，请求URL对应的资源
  * 接受到服务器的响应内容后，浏览器的HTML解析器，会将HTML文件解析成一棵DOM树，DOM树的构建是一个深度遍历的过程，当前节点的所有子节点都构建完成以后，才会去构建当前节点的下一个兄弟节点。
  * 将CSS解析成CSSOM树（CSS Rule Tree）
  * 根据DOM树和CSSOM树，来构建Render Tree（渲染树）,注意渲染树，并不等于DOM树，因为一些像head或display:none的东西，就没有必要放在渲染树中了。
  * 有了Render Tree，浏览器已经能知道网页中有哪些节点，各个节点的CSS定义，以及它们的从属关系，下一步操作就是Layout,顾名思义，就是计算出每个节点在屏幕中的位置。
  * Layout后，浏览器已经知道哪些节点要显示，每个节点的CSS属性是什么，每个节点在屏幕中的位置是哪里，就进入了最后一步painting,按照算出来的规则，通过显卡，把内容画到屏幕上。

* 重绘和回流概念

  * 重绘 repaint

    变某个元素的背景色、文字颜色、边框颜色等等不影响它周围或内部布局的属性时，屏幕的一部分要重画，但是元素的几何尺寸没有变。

  * 回流 reflow

    元件的几何尺寸变了，我们需要重新验证并计算Render Tree。是Render Tree的一部分或全部发生了变化。

### 7.组件中的name是干什么用的

* 组件递归操作
  vue允许组件模板调用自身，这在日常需求中也时有出现，此时我们就可以根据组件的name，来进行操作。

* .配合keep-alive对组件缓存做限制（include/exclude="name"）

  keep-alive的 include和exclude 允许有条件的对组件进行缓存,其中include和exclude所匹配的就是组件的name值。

* 在dev-tools中使用

  在开发中我们经常需要对代码进行调试，在dev-tools中组件是以组件name进行显示的，这样更有语义化，方便我们快速定位到我们需要审查的位置，结构更清晰明了。

### 8.router中的钩子函数用过哪些

### 9.为什么要用vue-cli

1. 为了快速开发一个应用，约定大于配置的思想。‘能不配置就不配置，方便快速开发业务’
2. webpack不太友好，配置太长了。 

### 10.怎么重置data中的数据

```js
this.$data.form = this.$options.data().form
```

```js
this.$data // 组件当前data对象
this.$options.data() // 组件初始化状态下的data对象

Object.assign(this.$data, this.$options.data()) // 重置data对象到初始化状态
```



### 11.addEventListent怎么用

* 概念

  ocument.addEventListener() 方法用于向文档添加事件句柄。

* 用法

  event： 描述事件描述的字符串。

  function：事件触发的函数。

  ```js
  document.addEventListener(event, function, useCapture)
  ```

* 例子

  ```js
  document.addEventListener("click", myFunc)
  
  function myFunc() {
      document.getelementById('demo').innerHTML = 'hello'
  }
  ```

* 兼容低版本的浏览器

  替换为 attachEvent 属性

  











